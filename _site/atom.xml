<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
   <title>Alan_kell</title>
   <link href="http://alankell.github.io/atom.xml" rel="self" type="application/atom+xml"/>
   <link href="http://alankell.github.io" rel="alternate" type="text/html" />
   <updated>2013-12-26T22:30:15+08:00</updated>
   <id>http://alankell.github.io</id>
   <author>
     <name></name>
     <email></email>
   </author>

   
   <entry>
     <title>淘宝技术这十年</title>
     <link href="http://alankell.github.io/taobao"/>
     <updated>2013-12-07T00:00:00+08:00</updated>
     <id>http://http://alankell.github.io/taobao</id>
     <content type="html">&lt;p&gt;　　初拿到这本书的时候，我大致浏览了一下，发现这里面的内容还是很有价值的，于是我想花一整块时间来好好研读。经过一个晚上的时间精度，发现，果不其然，这是一本好书，虽然前面的技术板块还是有很多不是很懂的，大量的专业名词不得不借用google，一路下来对淘宝的TFS（taobao file system）很好奇，但是由于技术的门槛，深究下去也有很大的难度，后来google的时候发现在同期腾讯也做了一个TFS（tencent file system），国内的这两大IT巨头，都做了自己的文件系统，这是这个信息时代发展的必然。随着大数据时代的来临，海量数据的存储和计算，使得一个系统发展到10亿流量的级别，你不得不做技术创新来满足现实中的需求。&lt;/p&gt;

&lt;p&gt;　　对于淘宝从初期的土鳖时代发展到现在的黄金时代，我也深刻地意识到，一个好的架构真的不是一触而就的，而是需要不断的升级和重构，比如初期，淘宝选择LAMP web 服务器架构，这也是可以理解的，因为刚起步，对并发量的要求并不需要很高，Apache的性能足以满足用户请求的需求，杀鸡用牛刀的法子真的没多大必要。但是随着用户量的暴增，就不得不升级架构了，Mysql到Oracle数据的转变，Apache到Nginx的转变成为必然，当然这之中的升级也并不是那么容易，因为不能升级期间让系统停掉，这样必然会引起用户的抱怨和不满，这中间运用的技术不由得我佩服得五体投地。并且我相信淘宝的服务器的架构图必然是多层的，比如下面这个：
&lt;img src=&quot;https://dl.dropboxusercontent.com/u/36894032/LAPM.jpg&quot; alt=&quot;lamp&quot; /&gt;
　　&lt;/p&gt;

&lt;p&gt;　　
然后，对于前端这块也是我最感兴趣的，现在硬件和浏览器的进步都是突飞猛进，对于网页的要求必然越来越高，传统的静态页面肯定是满足不了大众的，但是要实现绚丽的交互效果，加载的资源必然大幅增加，浏览器在同一域名下并发加载的资源数量是有限的，比如现在领先的chrome也就一般是4-6个，但是访问一次淘宝首页需要加载上百个资源，那么如此小的并发量必然会加载很久，所以作为前端开发人员要想突破这个限制，往往将这些文件分布在多个域名下，这就绕过浏览器的这个限制，这种小招互联网时代很常见，需要我们好好去积累。并且作为一个前端开发者，并不是只了解前端开发就够了，我们需要了解与服务器端怎么连接，SEO等等。&lt;/p&gt;

&lt;p&gt;　　前面那么多的名词让人很头大，后面的访谈让我感触很深，没有一个牛逼的人不是从苦逼走过来的，我们只有不断地去犯错，不断地碰壁，才能积累经验，领悟技术的真谛。人一生当中最重要的就是找到自己感兴趣的东西，然后坚持下去，追求自己喜欢的东西，再苦再累也不会为此感到后悔的。记得一年之前，我的一位导师这样跟我们说“至此，我对我能这样度过前半生感到无比的欣慰，因为我掌握了一门乐器，擅长一项运动，并且在自己喜欢的领域做研究，我觉得我是无憾了。” 想到这，我不禁黯然发笑，我是不是也应该为自己庆幸一下呢，哈哈，运动的话乒乓球也是我从小到大坚持的，现在也算是擅长的了，乐器的话，小时候也接触很多，笛子，口琴，后来是练起了吉他，虽然不算精通，但是拿出来装个逼还是可以的，:)  然后前端开发这块，热情也是时常爆表，憧憬只增不减，keep going！&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>http</title>
     <link href="http://alankell.github.io/http"/>
     <updated>2013-11-21T00:00:00+08:00</updated>
     <id>http://http://alankell.github.io/http</id>
     <content type="html">&lt;h1&gt;HTTP&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;Stability: 3 - Stable
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To use the HTTP server and client one must &lt;code&gt;require(&#39;http&#39;)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The HTTP interfaces in Node are designed to support many features
of the protocol which have been traditionally difficult to use.
In particular, large, possibly chunk-encoded, messages. The interface is
careful to never buffer entire requests or responses--the
user is able to stream data.&lt;/p&gt;

&lt;p&gt;HTTP message headers are represented by an object like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{ &#39;content-length&#39;: &#39;123&#39;,
  &#39;content-type&#39;: &#39;text/plain&#39;,
  &#39;connection&#39;: &#39;keep-alive&#39;,
  &#39;host&#39;: &#39;mysite.com&#39;,
  &#39;accept&#39;: &#39;*/*&#39; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Keys are lowercased. Values are not modified.&lt;/p&gt;

&lt;p&gt;In order to support the full spectrum of possible HTTP applications, Node&#39;s
HTTP API is very low-level. It deals with stream handling and message
parsing only. It parses a message into headers and body but it does not
parse the actual headers or the body.&lt;/p&gt;

&lt;p&gt;Defined headers that allow multiple values are concatenated with a &lt;code&gt;,&lt;/code&gt;
character, except for the &lt;code&gt;set-cookie&lt;/code&gt; and &lt;code&gt;cookie&lt;/code&gt; headers which are
represented as an array of values.  Headers such as &lt;code&gt;content-length&lt;/code&gt;
which can only have a single value are parsed accordingly, and only a
single value is represented on the parsed object.&lt;/p&gt;

&lt;p&gt;The raw headers as they were received are retained in the &lt;code&gt;rawHeaders&lt;/code&gt;
property, which is an array of &lt;code&gt;[key, value, key2, value2, ...]&lt;/code&gt;.  For
example, the previous message header object might have a &lt;code&gt;rawHeaders&lt;/code&gt;
list like the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[ &#39;ConTent-Length&#39;, &#39;123456&#39;,
  &#39;content-LENGTH&#39;, &#39;123&#39;,
  &#39;content-type&#39;, &#39;text/plain&#39;,
  &#39;CONNECTION&#39;, &#39;keep-alive&#39;,
  &#39;Host&#39;, &#39;mysite.com&#39;,
  &#39;accepT&#39;, &#39;*/*&#39; ]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;http.STATUS_CODES&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;{Object}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;A collection of all the standard HTTP response status codes, and the
short description of each.  For example, &lt;code&gt;http.STATUS_CODES[404] === &#39;Not
Found&#39;&lt;/code&gt;.&lt;/p&gt;

&lt;h2&gt;http.createServer([requestListener])&lt;/h2&gt;

&lt;p&gt;Returns a new web server object.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;requestListener&lt;/code&gt; is a function which is automatically
added to the &lt;code&gt;&#39;request&#39;&lt;/code&gt; event.&lt;/p&gt;

&lt;h2&gt;http.createClient([port], [host])&lt;/h2&gt;

&lt;p&gt;This function is &lt;strong&gt;deprecated&lt;/strong&gt;; please use &lt;a href=&quot;#http_http_request_options_callback&quot;&gt;http.request()&lt;/a&gt; instead.
Constructs a new HTTP client. &lt;code&gt;port&lt;/code&gt; and &lt;code&gt;host&lt;/code&gt; refer to the server to be
connected to.&lt;/p&gt;

&lt;h2&gt;Class: http.Server&lt;/h2&gt;

&lt;p&gt;This is an &lt;a href=&quot;events.html#events_class_events_eventemitter&quot;&gt;EventEmitter&lt;/a&gt; with the following events:&lt;/p&gt;

&lt;h3&gt;Event: &#39;request&#39;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;function (request, response) { }&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Emitted each time there is a request. Note that there may be multiple requests
per connection (in the case of keep-alive connections).
&lt;code&gt;request&lt;/code&gt; is an instance of &lt;code&gt;http.IncomingMessage&lt;/code&gt; and &lt;code&gt;response&lt;/code&gt; is
an instance of &lt;code&gt;http.ServerResponse&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;Event: &#39;connection&#39;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;function (socket) { }&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;When a new TCP stream is established. &lt;code&gt;socket&lt;/code&gt; is an object of type
&lt;code&gt;net.Socket&lt;/code&gt;. Usually users will not want to access this event. In
particular, the socket will not emit &lt;code&gt;readable&lt;/code&gt; events because of how
the protocol parser attaches to the socket. The &lt;code&gt;socket&lt;/code&gt; can also be
accessed at &lt;code&gt;request.connection&lt;/code&gt;.&lt;/p&gt;

&lt;h3&gt;Event: &#39;close&#39;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;function () { }&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Emitted when the server closes.&lt;/p&gt;

&lt;h3&gt;Event: &#39;checkContinue&#39;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;function (request, response) { }&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Emitted each time a request with an http Expect: 100-continue is received.
If this event isn&#39;t listened for, the server will automatically respond
with a 100 Continue as appropriate.&lt;/p&gt;

&lt;p&gt;Handling this event involves calling &lt;code&gt;response.writeContinue&lt;/code&gt; if the client
should continue to send the request body, or generating an appropriate HTTP
response (e.g., 400 Bad Request) if the client should not continue to send the
request body.&lt;/p&gt;

&lt;p&gt;Note that when this event is emitted and handled, the &lt;code&gt;request&lt;/code&gt; event will
not be emitted.&lt;/p&gt;

&lt;h3&gt;Event: &#39;connect&#39;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;function (request, socket, head) { }&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Emitted each time a client requests a http CONNECT method. If this event isn&#39;t
listened for, then clients requesting a CONNECT method will have their
connections closed.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;request&lt;/code&gt; is the arguments for the http request, as it is in the request
event.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;socket&lt;/code&gt; is the network socket between the server and client.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;head&lt;/code&gt; is an instance of Buffer, the first packet of the tunneling stream,
this may be empty.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;After this event is emitted, the request&#39;s socket will not have a &lt;code&gt;data&lt;/code&gt;
event listener, meaning you will need to bind to it in order to handle data
sent to the server on that socket.&lt;/p&gt;

&lt;h3&gt;Event: &#39;upgrade&#39;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;function (request, socket, head) { }&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Emitted each time a client requests a http upgrade. If this event isn&#39;t
listened for, then clients requesting an upgrade will have their connections
closed.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;request&lt;/code&gt; is the arguments for the http request, as it is in the request
event.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;socket&lt;/code&gt; is the network socket between the server and client.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;head&lt;/code&gt; is an instance of Buffer, the first packet of the upgraded stream,
this may be empty.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;After this event is emitted, the request&#39;s socket will not have a &lt;code&gt;data&lt;/code&gt;
event listener, meaning you will need to bind to it in order to handle data
sent to the server on that socket.&lt;/p&gt;

&lt;h3&gt;Event: &#39;clientError&#39;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;function (exception, socket) { }&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;If a client connection emits an &#39;error&#39; event - it will forwarded here.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;socket&lt;/code&gt; is the &lt;code&gt;net.Socket&lt;/code&gt; object that the error originated from.&lt;/p&gt;

&lt;h3&gt;server.listen(port, [hostname], [backlog], [callback])&lt;/h3&gt;

&lt;p&gt;Begin accepting connections on the specified port and hostname.  If the
hostname is omitted, the server will accept connections directed to any
IPv4 address (&lt;code&gt;INADDR_ANY&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;To listen to a unix socket, supply a filename instead of port and hostname.&lt;/p&gt;

&lt;p&gt;Backlog is the maximum length of the queue of pending connections.
The actual length will be determined by your OS through sysctl settings such as
&lt;code&gt;tcp_max_syn_backlog&lt;/code&gt; and &lt;code&gt;somaxconn&lt;/code&gt; on linux. The default value of this
parameter is 511 (not 512).&lt;/p&gt;

&lt;p&gt;This function is asynchronous. The last parameter &lt;code&gt;callback&lt;/code&gt; will be added as
a listener for the &lt;a href=&quot;net.html#net_event_listening&quot;&gt;&#39;listening&#39;&lt;/a&gt; event.  See also &lt;a href=&quot;net.html#net_server_listen_port_host_backlog_callback&quot;&gt;net.Server.listen(port)&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;server.listen(path, [callback])&lt;/h3&gt;

&lt;p&gt;Start a UNIX socket server listening for connections on the given &lt;code&gt;path&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This function is asynchronous. The last parameter &lt;code&gt;callback&lt;/code&gt; will be added as
a listener for the &lt;a href=&quot;net.html#net_event_listening&quot;&gt;&#39;listening&#39;&lt;/a&gt; event.  See also &lt;a href=&quot;net.html#net_server_listen_path_callback&quot;&gt;net.Server.listen(path)&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;server.listen(handle, [callback])&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;handle&lt;/code&gt; {Object}&lt;/li&gt;
&lt;li&gt;&lt;code&gt;callback&lt;/code&gt; {Function}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The &lt;code&gt;handle&lt;/code&gt; object can be set to either a server or socket (anything
with an underlying &lt;code&gt;_handle&lt;/code&gt; member), or a &lt;code&gt;{fd: &amp;lt;n&amp;gt;}&lt;/code&gt; object.&lt;/p&gt;

&lt;p&gt;This will cause the server to accept connections on the specified
handle, but it is presumed that the file descriptor or handle has
already been bound to a port or domain socket.&lt;/p&gt;

&lt;p&gt;Listening on a file descriptor is not supported on Windows.&lt;/p&gt;

&lt;p&gt;This function is asynchronous. The last parameter &lt;code&gt;callback&lt;/code&gt; will be added as
a listener for the &lt;a href=&quot;net.html#event_listening_&quot;&gt;&#39;listening&#39;&lt;/a&gt; event.
See also &lt;a href=&quot;net.html#net_server_listen_handle_callback&quot;&gt;net.Server.listen()&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;server.close([callback])&lt;/h3&gt;

&lt;p&gt;Stops the server from accepting new connections.  See &lt;a href=&quot;net.html#net_server_close_callback&quot;&gt;net.Server.close()&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;server.maxHeadersCount&lt;/h3&gt;

&lt;p&gt;Limits maximum incoming headers count, equal to 1000 by default. If set to 0 -
no limit will be applied.&lt;/p&gt;

&lt;h3&gt;server.setTimeout(msecs, callback)&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;msecs&lt;/code&gt; {Number}&lt;/li&gt;
&lt;li&gt;&lt;code&gt;callback&lt;/code&gt; {Function}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Sets the timeout value for sockets, and emits a &lt;code&gt;&#39;timeout&#39;&lt;/code&gt; event on
the Server object, passing the socket as an argument, if a timeout
occurs.&lt;/p&gt;

&lt;p&gt;If there is a &lt;code&gt;&#39;timeout&#39;&lt;/code&gt; event listener on the Server object, then it
will be called with the timed-out socket as an argument.&lt;/p&gt;

&lt;p&gt;By default, the Server&#39;s timeout value is 2 minutes, and sockets are
destroyed automatically if they time out.  However, if you assign a
callback to the Server&#39;s &lt;code&gt;&#39;timeout&#39;&lt;/code&gt; event, then you are responsible
for handling socket timeouts.&lt;/p&gt;

&lt;h3&gt;server.timeout&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;{Number} Default = 120000 (2 minutes)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The number of milliseconds of inactivity before a socket is presumed
to have timed out.&lt;/p&gt;

&lt;p&gt;Note that the socket timeout logic is set up on connection, so
changing this value only affects &lt;em&gt;new&lt;/em&gt; connections to the server, not
any existing connections.&lt;/p&gt;

&lt;p&gt;Set to 0 to disable any kind of automatic timeout behavior on incoming
connections.&lt;/p&gt;

&lt;h2&gt;Class: http.ServerResponse&lt;/h2&gt;

&lt;p&gt;This object is created internally by a HTTP server--not by the user. It is
passed as the second parameter to the &lt;code&gt;&#39;request&#39;&lt;/code&gt; event.&lt;/p&gt;

&lt;p&gt;The response implements the &lt;a href=&quot;stream.html#stream_writable_stream&quot;&gt;Writable Stream&lt;/a&gt; interface. This is an
&lt;a href=&quot;events.html#events_class_events_eventemitter&quot;&gt;EventEmitter&lt;/a&gt; with the following events:&lt;/p&gt;

&lt;h3&gt;Event: &#39;close&#39;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;function () { }&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Indicates that the underlying connection was terminated before
&lt;code&gt;response.end()&lt;/code&gt; was called or able to flush.&lt;/p&gt;

&lt;h3&gt;response.writeContinue()&lt;/h3&gt;

&lt;p&gt;Sends a HTTP/1.1 100 Continue message to the client, indicating that
the request body should be sent. See the &lt;a href=&quot;#http_event_checkcontinue&quot;&gt;&#39;checkContinue&#39;&lt;/a&gt; event on &lt;code&gt;Server&lt;/code&gt;.&lt;/p&gt;

&lt;h3&gt;response.writeHead(statusCode, [statusMessage], [headers])&lt;/h3&gt;

&lt;p&gt;Sends a response header to the request. The status code is a 3-digit HTTP
status code, like &lt;code&gt;404&lt;/code&gt;. The last argument, &lt;code&gt;headers&lt;/code&gt;, are the response headers.
Optionally one can give a human-readable &lt;code&gt;statusMessage&lt;/code&gt; as the second
argument.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var body = &#39;hello world&#39;;
response.writeHead(200, {
  &#39;Content-Length&#39;: body.length,
  &#39;Content-Type&#39;: &#39;text/plain&#39; });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This method must only be called once on a message and it must
be called before &lt;code&gt;response.end()&lt;/code&gt; is called.&lt;/p&gt;

&lt;p&gt;If you call &lt;code&gt;response.write()&lt;/code&gt; or &lt;code&gt;response.end()&lt;/code&gt; before calling this, the
implicit/mutable headers will be calculated and call this function for you.&lt;/p&gt;

&lt;p&gt;Note: that Content-Length is given in bytes not characters. The above example
works because the string &lt;code&gt;&#39;hello world&#39;&lt;/code&gt; contains only single byte characters.
If the body contains higher coded characters then &lt;code&gt;Buffer.byteLength()&lt;/code&gt;
should be used to determine the number of bytes in a given encoding.
And Node does not check whether Content-Length and the length of the body
which has been transmitted are equal or not.&lt;/p&gt;

&lt;h3&gt;response.setTimeout(msecs, callback)&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;msecs&lt;/code&gt; {Number}&lt;/li&gt;
&lt;li&gt;&lt;code&gt;callback&lt;/code&gt; {Function}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Sets the Socket&#39;s timeout value to &lt;code&gt;msecs&lt;/code&gt;.  If a callback is
provided, then it is added as a listener on the &lt;code&gt;&#39;timeout&#39;&lt;/code&gt; event on
the response object.&lt;/p&gt;

&lt;p&gt;If no &lt;code&gt;&#39;timeout&#39;&lt;/code&gt; listener is added to the request, the response, or
the server, then sockets are destroyed when they time out.  If you
assign a handler on the request, the response, or the server&#39;s
&lt;code&gt;&#39;timeout&#39;&lt;/code&gt; events, then it is your responsibility to handle timed out
sockets.&lt;/p&gt;

&lt;h3&gt;response.statusCode&lt;/h3&gt;

&lt;p&gt;When using implicit headers (not calling &lt;code&gt;response.writeHead()&lt;/code&gt; explicitly), this property
controls the status code that will be sent to the client when the headers get
flushed.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;response.statusCode = 404;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After response header was sent to the client, this property indicates the
status code which was sent out.&lt;/p&gt;

&lt;h3&gt;response.statusMessage&lt;/h3&gt;

&lt;p&gt;When using implicit headers (not calling &lt;code&gt;response.writeHead()&lt;/code&gt; explicitly), this property
controls the status message that will be sent to the client when the headers get
flushed. If this is left as &lt;code&gt;undefined&lt;/code&gt; then the standard message for the status
code will be used.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;response.statusMessage = &#39;Not found&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After response header was sent to the client, this property indicates the
status message which was sent out.&lt;/p&gt;

&lt;h3&gt;response.setHeader(name, value)&lt;/h3&gt;

&lt;p&gt;Sets a single header value for implicit headers.  If this header already exists
in the to-be-sent headers, its value will be replaced.  Use an array of strings
here if you need to send multiple headers with the same name.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;response.setHeader(&quot;Content-Type&quot;, &quot;text/html&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;response.setHeader(&quot;Set-Cookie&quot;, [&quot;type=ninja&quot;, &quot;language=javascript&quot;]);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;response.headersSent&lt;/h3&gt;

&lt;p&gt;Boolean (read-only). True if headers were sent, false otherwise.&lt;/p&gt;

&lt;h3&gt;response.sendDate&lt;/h3&gt;

&lt;p&gt;When true, the Date header will be automatically generated and sent in
the response if it is not already present in the headers. Defaults to true.&lt;/p&gt;

&lt;p&gt;This should only be disabled for testing; HTTP requires the Date header
in responses.&lt;/p&gt;

&lt;h3&gt;response.getHeader(name)&lt;/h3&gt;

&lt;p&gt;Reads out a header that&#39;s already been queued but not sent to the client.  Note
that the name is case insensitive.  This can only be called before headers get
implicitly flushed.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var contentType = response.getHeader(&#39;content-type&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;response.removeHeader(name)&lt;/h3&gt;

&lt;p&gt;Removes a header that&#39;s queued for implicit sending.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;response.removeHeader(&quot;Content-Encoding&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;response.write(chunk, [encoding])&lt;/h3&gt;

&lt;p&gt;If this method is called and &lt;code&gt;response.writeHead()&lt;/code&gt; has not been called, it will
switch to implicit header mode and flush the implicit headers.&lt;/p&gt;

&lt;p&gt;This sends a chunk of the response body. This method may
be called multiple times to provide successive parts of the body.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;chunk&lt;/code&gt; can be a string or a buffer. If &lt;code&gt;chunk&lt;/code&gt; is a string,
the second parameter specifies how to encode it into a byte stream.
By default the &lt;code&gt;encoding&lt;/code&gt; is &lt;code&gt;&#39;utf8&#39;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: This is the raw HTTP body and has nothing to do with
higher-level multi-part body encodings that may be used.&lt;/p&gt;

&lt;p&gt;The first time &lt;code&gt;response.write()&lt;/code&gt; is called, it will send the buffered
header information and the first body to the client. The second time
&lt;code&gt;response.write()&lt;/code&gt; is called, Node assumes you&#39;re going to be streaming
data, and sends that separately. That is, the response is buffered up to the
first chunk of body.&lt;/p&gt;

&lt;p&gt;Returns &lt;code&gt;true&lt;/code&gt; if the entire data was flushed successfully to the kernel
buffer. Returns &lt;code&gt;false&lt;/code&gt; if all or part of the data was queued in user memory.
&lt;code&gt;&#39;drain&#39;&lt;/code&gt; will be emitted when the buffer is again free.&lt;/p&gt;

&lt;h3&gt;response.addTrailers(headers)&lt;/h3&gt;

&lt;p&gt;This method adds HTTP trailing headers (a header but at the end of the
message) to the response.&lt;/p&gt;

&lt;p&gt;Trailers will &lt;strong&gt;only&lt;/strong&gt; be emitted if chunked encoding is used for the
response; if it is not (e.g., if the request was HTTP/1.0), they will
be silently discarded.&lt;/p&gt;

&lt;p&gt;Note that HTTP requires the &lt;code&gt;Trailer&lt;/code&gt; header to be sent if you intend to
emit trailers, with a list of the header fields in its value. E.g.,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;response.writeHead(200, { &#39;Content-Type&#39;: &#39;text/plain&#39;,
                          &#39;Trailer&#39;: &#39;Content-MD5&#39; });
response.write(fileData);
response.addTrailers({&#39;Content-MD5&#39;: &quot;7895bf4b8828b55ceaf47747b4bca667&quot;});
response.end();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;response.end([data], [encoding])&lt;/h3&gt;

&lt;p&gt;This method signals to the server that all of the response headers and body
have been sent; that server should consider this message complete.
The method, &lt;code&gt;response.end()&lt;/code&gt;, MUST be called on each
response.&lt;/p&gt;

&lt;p&gt;If &lt;code&gt;data&lt;/code&gt; is specified, it is equivalent to calling &lt;code&gt;response.write(data, encoding)&lt;/code&gt;
followed by &lt;code&gt;response.end()&lt;/code&gt;.&lt;/p&gt;

&lt;h2&gt;http.request(options, callback)&lt;/h2&gt;

&lt;p&gt;Node maintains several connections per server to make HTTP requests.
This function allows one to transparently issue requests.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;options&lt;/code&gt; can be an object or a string. If &lt;code&gt;options&lt;/code&gt; is a string, it is
automatically parsed with &lt;a href=&quot;url.html#url_url_parse_urlstr_parsequerystring_slashesdenotehost&quot;&gt;url.parse()&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Options:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;host&lt;/code&gt;: A domain name or IP address of the server to issue the request to.
Defaults to &lt;code&gt;&#39;localhost&#39;&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hostname&lt;/code&gt;: To support &lt;code&gt;url.parse()&lt;/code&gt; &lt;code&gt;hostname&lt;/code&gt; is preferred over &lt;code&gt;host&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;port&lt;/code&gt;: Port of remote server. Defaults to 80.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;localAddress&lt;/code&gt;: Local interface to bind for network connections.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;socketPath&lt;/code&gt;: Unix Domain Socket (use one of host:port or socketPath)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;method&lt;/code&gt;: A string specifying the HTTP request method. Defaults to &lt;code&gt;&#39;GET&#39;&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;path&lt;/code&gt;: Request path. Defaults to &lt;code&gt;&#39;/&#39;&lt;/code&gt;. Should include query string if any.
E.G. &lt;code&gt;&#39;/index.html?page=12&#39;&lt;/code&gt;. An exception is thrown when the request path
contains illegal characters. Currently, only spaces are rejected but that
may change in the future.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;headers&lt;/code&gt;: An object containing request headers.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;auth&lt;/code&gt;: Basic authentication i.e. &lt;code&gt;&#39;user:password&#39;&lt;/code&gt; to compute an
Authorization header.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;agent&lt;/code&gt;: Controls &lt;a href=&quot;#http_class_http_agent&quot;&gt;Agent&lt;/a&gt; behavior. When an Agent is used request will
default to &lt;code&gt;Connection: keep-alive&lt;/code&gt;. Possible values:&lt;/li&gt;
&lt;li&gt;&lt;code&gt;undefined&lt;/code&gt; (default): use &lt;a href=&quot;#http_http_globalagent&quot;&gt;global Agent&lt;/a&gt; for this host and port.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Agent&lt;/code&gt; object: explicitly use the passed in &lt;code&gt;Agent&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;false&lt;/code&gt;: opts out of connection pooling with an Agent, defaults request to
&lt;code&gt;Connection: close&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;keepAlive&lt;/code&gt;: {Boolean} Keep sockets around in a pool to be used
by other requests in the future. Default = &lt;code&gt;false&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;keepAliveMsecs&lt;/code&gt;: {Integer} When using HTTP KeepAlive, how often to
send TCP KeepAlive packets over sockets being kept alive.  Default =
&lt;code&gt;1000&lt;/code&gt;.  Only relevant if &lt;code&gt;keepAlive&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;code&gt;http.request()&lt;/code&gt; returns an instance of the &lt;code&gt;http.ClientRequest&lt;/code&gt;
class. The &lt;code&gt;ClientRequest&lt;/code&gt; instance is a writable stream. If one needs to
upload a file with a POST request, then write to the &lt;code&gt;ClientRequest&lt;/code&gt; object.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var options = {
  hostname: &#39;www.google.com&#39;,
  port: 80,
  path: &#39;/upload&#39;,
  method: &#39;POST&#39;
};

var req = http.request(options, function(res) {
  console.log(&#39;STATUS: &#39; + res.statusCode);
  console.log(&#39;HEADERS: &#39; + JSON.stringify(res.headers));
  res.setEncoding(&#39;utf8&#39;);
  res.on(&#39;data&#39;, function (chunk) {
    console.log(&#39;BODY: &#39; + chunk);
  });
});

req.on(&#39;error&#39;, function(e) {
  console.log(&#39;problem with request: &#39; + e.message);
});

// write data to request body
req.write(&#39;data\n&#39;);
req.write(&#39;data\n&#39;);
req.end();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that in the example &lt;code&gt;req.end()&lt;/code&gt; was called. With &lt;code&gt;http.request()&lt;/code&gt; one
must always call &lt;code&gt;req.end()&lt;/code&gt; to signify that you&#39;re done with the request -
even if there is no data being written to the request body.&lt;/p&gt;

&lt;p&gt;If any error is encountered during the request (be that with DNS resolution,
TCP level errors, or actual HTTP parse errors) an &lt;code&gt;&#39;error&#39;&lt;/code&gt; event is emitted
on the returned request object.&lt;/p&gt;

&lt;p&gt;There are a few special headers that should be noted.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Sending a &#39;Connection: keep-alive&#39; will notify Node that the connection to
the server should be persisted until the next request.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Sending a &#39;Content-length&#39; header will disable the default chunked encoding.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Sending an &#39;Expect&#39; header will immediately send the request headers.
Usually, when sending &#39;Expect: 100-continue&#39;, you should both set a timeout
and listen for the &lt;code&gt;continue&lt;/code&gt; event. See RFC2616 Section 8.2.3 for more
information.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Sending an Authorization header will override using the &lt;code&gt;auth&lt;/code&gt; option
to compute basic authentication.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;http.get(options, callback)&lt;/h2&gt;

&lt;p&gt;Since most requests are GET requests without bodies, Node provides this
convenience method. The only difference between this method and &lt;code&gt;http.request()&lt;/code&gt;
is that it sets the method to GET and calls &lt;code&gt;req.end()&lt;/code&gt; automatically.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http.get(&quot;http://www.google.com/index.html&quot;, function(res) {
  console.log(&quot;Got response: &quot; + res.statusCode);
}).on(&#39;error&#39;, function(e) {
  console.log(&quot;Got error: &quot; + e.message);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Class: http.Agent&lt;/h2&gt;

&lt;p&gt;The HTTP Agent is used for pooling sockets used in HTTP client
requests.&lt;/p&gt;

&lt;p&gt;The HTTP Agent also defaults client requests to using
Connection:keep-alive. If no pending HTTP requests are waiting on a
socket to become free the socket is closed. This means that Node&#39;s
pool has the benefit of keep-alive when under load but still does not
require developers to manually close the HTTP clients using
KeepAlive.&lt;/p&gt;

&lt;p&gt;If you opt into using HTTP KeepAlive, you can create an Agent object
with that flag set to &lt;code&gt;true&lt;/code&gt;.  (See the &lt;a href=&quot;#http_new_agent_options&quot;&gt;constructor
options&lt;/a&gt; below.)  Then, the Agent will keep
unused sockets in a pool for later use.  They will be explicitly
marked so as to not keep the Node process running.  However, it is
still a good idea to explicitly &lt;a href=&quot;#http_agent_destroy&quot;&gt;&lt;code&gt;destroy()&lt;/code&gt;&lt;/a&gt;
KeepAlive agents when they are no longer in use, so that the Sockets
will be shut down.&lt;/p&gt;

&lt;p&gt;Sockets are removed from the agent&#39;s pool when the socket emits either
a &quot;close&quot; event or a special &quot;agentRemove&quot; event. This means that if
you intend to keep one HTTP request open for a long time and don&#39;t
want it to stay in the pool you can do something along the lines of:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http.get(options, function(res) {
  // Do stuff
}).on(&quot;socket&quot;, function (socket) {
  socket.emit(&quot;agentRemove&quot;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alternatively, you could just opt out of pooling entirely using
&lt;code&gt;agent:false&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http.get({
  hostname: &#39;localhost&#39;,
  port: 80,
  path: &#39;/&#39;,
  agent: false  // create a new agent just for this one request
}, function (res) {
  // Do stuff with response
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;new Agent([options])&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;options&lt;/code&gt; {Object} Set of configurable options to set on the agent.
Can have the following fields:

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;keepAlive&lt;/code&gt; {Boolean} Keep sockets around in a pool to be used by
other requests in the future. Default = &lt;code&gt;false&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;keepAliveMsecs&lt;/code&gt; {Integer} When using HTTP KeepAlive, how often
to send TCP KeepAlive packets over sockets being kept alive.
Default = &lt;code&gt;1000&lt;/code&gt;.  Only relevant if &lt;code&gt;keepAlive&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;maxSockets&lt;/code&gt; {Number} Maximum number of sockets to allow per
host.  Default = &lt;code&gt;Infinity&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;maxFreeSockets&lt;/code&gt; {Number} Maximum number of sockets to leave open
in a free state.  Only relevant if &lt;code&gt;keepAlive&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;.
Default = &lt;code&gt;256&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The default &lt;code&gt;http.globalAgent&lt;/code&gt; that is used by &lt;code&gt;http.request&lt;/code&gt; has all
of these values set to their respective defaults.&lt;/p&gt;

&lt;p&gt;To configure any of them, you must create your own &lt;code&gt;Agent&lt;/code&gt; object.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;var http = require(&#39;http&#39;);
var keepAliveAgent = new http.Agent({ keepAlive: true });
keepAliveAgent.request(options, onResponseCallback);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;agent.maxSockets&lt;/h3&gt;

&lt;p&gt;By default set to Infinity. Determines how many concurrent sockets the
agent can have open per host.&lt;/p&gt;

&lt;h3&gt;agent.maxFreeSockets&lt;/h3&gt;

&lt;p&gt;By default set to 256.  For Agents supporting HTTP KeepAlive, this
sets the maximum number of sockets that will be left open in the free
state.&lt;/p&gt;

&lt;h3&gt;agent.sockets&lt;/h3&gt;

&lt;p&gt;An object which contains arrays of sockets currently in use by the
Agent.  Do not modify.&lt;/p&gt;

&lt;h3&gt;agent.freeSockets&lt;/h3&gt;

&lt;p&gt;An object which contains arrays of sockets currently awaiting use by
the Agent when HTTP KeepAlive is used.  Do not modify.&lt;/p&gt;

&lt;h3&gt;agent.requests&lt;/h3&gt;

&lt;p&gt;An object which contains queues of requests that have not yet been assigned to
sockets. Do not modify.&lt;/p&gt;

&lt;h3&gt;agent.destroy()&lt;/h3&gt;

&lt;p&gt;Destroy any sockets that are currently in use by the agent.&lt;/p&gt;

&lt;p&gt;It is usually not necessary to do this.  However, if you are using an
agent with KeepAlive enabled, then it is best to explicitly shut down
the agent when you know that it will no longer be used.  Otherwise,
sockets may hang open for quite a long time before the server
terminates them.&lt;/p&gt;

&lt;h3&gt;agent.getName(options)&lt;/h3&gt;

&lt;p&gt;Get a unique name for a set of request options, to determine whether a
connection can be reused.  In the http agent, this returns
&lt;code&gt;host:port:localAddress&lt;/code&gt;.  In the https agent, the name includes the
CA, cert, ciphers, and other HTTPS/TLS-specific options that determine
socket reusability.&lt;/p&gt;

&lt;h2&gt;http.globalAgent&lt;/h2&gt;

&lt;p&gt;Global instance of Agent which is used as the default for all http client
requests.&lt;/p&gt;

&lt;h2&gt;Class: http.ClientRequest&lt;/h2&gt;

&lt;p&gt;This object is created internally and returned from &lt;code&gt;http.request()&lt;/code&gt;.  It
represents an &lt;em&gt;in-progress&lt;/em&gt; request whose header has already been queued.  The
header is still mutable using the &lt;code&gt;setHeader(name, value)&lt;/code&gt;, &lt;code&gt;getHeader(name)&lt;/code&gt;,
&lt;code&gt;removeHeader(name)&lt;/code&gt; API.  The actual header will be sent along with the first
data chunk or when closing the connection.&lt;/p&gt;

&lt;p&gt;To get the response, add a listener for &lt;code&gt;&#39;response&#39;&lt;/code&gt; to the request object.
&lt;code&gt;&#39;response&#39;&lt;/code&gt; will be emitted from the request object when the response
headers have been received.  The &lt;code&gt;&#39;response&#39;&lt;/code&gt; event is executed with one
argument which is an instance of &lt;code&gt;http.IncomingMessage&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;During the &lt;code&gt;&#39;response&#39;&lt;/code&gt; event, one can add listeners to the
response object; particularly to listen for the &lt;code&gt;&#39;data&#39;&lt;/code&gt; event.&lt;/p&gt;

&lt;p&gt;If no &lt;code&gt;&#39;response&#39;&lt;/code&gt; handler is added, then the response will be
entirely discarded.  However, if you add a &lt;code&gt;&#39;response&#39;&lt;/code&gt; event handler,
then you &lt;strong&gt;must&lt;/strong&gt; consume the data from the response object, either by
calling &lt;code&gt;response.read()&lt;/code&gt; whenever there is a &lt;code&gt;&#39;readable&#39;&lt;/code&gt; event, or
by adding a &lt;code&gt;&#39;data&#39;&lt;/code&gt; handler, or by calling the &lt;code&gt;.resume()&lt;/code&gt; method.
Until the data is consumed, the &lt;code&gt;&#39;end&#39;&lt;/code&gt; event will not fire.  Also, until
the data is read it will consume memory that can eventually lead to a
&#39;process out of memory&#39; error.&lt;/p&gt;

&lt;p&gt;Note: Node does not check whether Content-Length and the length of the body
which has been transmitted are equal or not.&lt;/p&gt;

&lt;p&gt;The request implements the &lt;a href=&quot;stream.html#stream_writable_stream&quot;&gt;Writable Stream&lt;/a&gt; interface. This is an
&lt;a href=&quot;events.html#events_class_events_eventemitter&quot;&gt;EventEmitter&lt;/a&gt; with the following events:&lt;/p&gt;

&lt;h3&gt;Event &#39;response&#39;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;function (response) { }&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Emitted when a response is received to this request. This event is emitted only
once. The &lt;code&gt;response&lt;/code&gt; argument will be an instance of &lt;code&gt;http.IncomingMessage&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Options:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;host&lt;/code&gt;: A domain name or IP address of the server to issue the request to.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;port&lt;/code&gt;: Port of remote server.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;socketPath&lt;/code&gt;: Unix Domain Socket (use one of host:port or socketPath)&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;Event: &#39;socket&#39;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;function (socket) { }&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Emitted after a socket is assigned to this request.&lt;/p&gt;

&lt;h3&gt;Event: &#39;connect&#39;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;function (response, socket, head) { }&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Emitted each time a server responds to a request with a CONNECT method. If this
event isn&#39;t being listened for, clients receiving a CONNECT method will have
their connections closed.&lt;/p&gt;

&lt;p&gt;A client server pair that show you how to listen for the &lt;code&gt;connect&lt;/code&gt; event.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var http = require(&#39;http&#39;);
var net = require(&#39;net&#39;);
var url = require(&#39;url&#39;);

// Create an HTTP tunneling proxy
var proxy = http.createServer(function (req, res) {
  res.writeHead(200, {&#39;Content-Type&#39;: &#39;text/plain&#39;});
  res.end(&#39;okay&#39;);
});
proxy.on(&#39;connect&#39;, function(req, cltSocket, head) {
  // connect to an origin server
  var srvUrl = url.parse(&#39;http://&#39; + req.url);
  var srvSocket = net.connect(srvUrl.port, srvUrl.hostname, function() {
    cltSocket.write(&#39;HTTP/1.1 200 Connection Established\r\n&#39; +
                    &#39;Proxy-agent: Node-Proxy\r\n&#39; +
                    &#39;\r\n&#39;);
    srvSocket.write(head);
    srvSocket.pipe(cltSocket);
    cltSocket.pipe(srvSocket);
  });
});

// now that proxy is running
proxy.listen(1337, &#39;127.0.0.1&#39;, function() {

  // make a request to a tunneling proxy
  var options = {
    port: 1337,
    hostname: &#39;127.0.0.1&#39;,
    method: &#39;CONNECT&#39;,
    path: &#39;www.google.com:80&#39;
  };

  var req = http.request(options);
  req.end();

  req.on(&#39;connect&#39;, function(res, socket, head) {
    console.log(&#39;got connected!&#39;);

    // make a request over an HTTP tunnel
    socket.write(&#39;GET / HTTP/1.1\r\n&#39; +
                 &#39;Host: www.google.com:80\r\n&#39; +
                 &#39;Connection: close\r\n&#39; +
                 &#39;\r\n&#39;);
    socket.on(&#39;data&#39;, function(chunk) {
      console.log(chunk.toString());
    });
    socket.on(&#39;end&#39;, function() {
      proxy.close();
    });
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Event: &#39;upgrade&#39;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;function (response, socket, head) { }&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Emitted each time a server responds to a request with an upgrade. If this
event isn&#39;t being listened for, clients receiving an upgrade header will have
their connections closed.&lt;/p&gt;

&lt;p&gt;A client server pair that show you how to listen for the &lt;code&gt;upgrade&lt;/code&gt; event.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var http = require(&#39;http&#39;);

// Create an HTTP server
var srv = http.createServer(function (req, res) {
  res.writeHead(200, {&#39;Content-Type&#39;: &#39;text/plain&#39;});
  res.end(&#39;okay&#39;);
});
srv.on(&#39;upgrade&#39;, function(req, socket, head) {
  socket.write(&#39;HTTP/1.1 101 Web Socket Protocol Handshake\r\n&#39; +
               &#39;Upgrade: WebSocket\r\n&#39; +
               &#39;Connection: Upgrade\r\n&#39; +
               &#39;\r\n&#39;);

  socket.pipe(socket); // echo back
});

// now that server is running
srv.listen(1337, &#39;127.0.0.1&#39;, function() {

  // make a request
  var options = {
    port: 1337,
    hostname: &#39;127.0.0.1&#39;,
    headers: {
      &#39;Connection&#39;: &#39;Upgrade&#39;,
      &#39;Upgrade&#39;: &#39;websocket&#39;
    }
  };

  var req = http.request(options);
  req.end();

  req.on(&#39;upgrade&#39;, function(res, socket, upgradeHead) {
    console.log(&#39;got upgraded!&#39;);
    socket.end();
    process.exit(0);
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Event: &#39;continue&#39;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;function () { }&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Emitted when the server sends a &#39;100 Continue&#39; HTTP response, usually because
the request contained &#39;Expect: 100-continue&#39;. This is an instruction that
the client should send the request body.&lt;/p&gt;

&lt;h3&gt;request.write(chunk, [encoding])&lt;/h3&gt;

&lt;p&gt;Sends a chunk of the body.  By calling this method
many times, the user can stream a request body to a
server--in that case it is suggested to use the
&lt;code&gt;[&#39;Transfer-Encoding&#39;, &#39;chunked&#39;]&lt;/code&gt; header line when
creating the request.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;chunk&lt;/code&gt; argument should be a &lt;a href=&quot;buffer.html#buffer_buffer&quot;&gt;Buffer&lt;/a&gt; or a string.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;encoding&lt;/code&gt; argument is optional and only applies when &lt;code&gt;chunk&lt;/code&gt; is a string.
Defaults to &lt;code&gt;&#39;utf8&#39;&lt;/code&gt;.&lt;/p&gt;

&lt;h3&gt;request.end([data], [encoding])&lt;/h3&gt;

&lt;p&gt;Finishes sending the request. If any parts of the body are
unsent, it will flush them to the stream. If the request is
chunked, this will send the terminating &lt;code&gt;&#39;0\r\n\r\n&#39;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If &lt;code&gt;data&lt;/code&gt; is specified, it is equivalent to calling
&lt;code&gt;request.write(data, encoding)&lt;/code&gt; followed by &lt;code&gt;request.end()&lt;/code&gt;.&lt;/p&gt;

&lt;h3&gt;request.abort()&lt;/h3&gt;

&lt;p&gt;Aborts a request.  (New since v0.3.8.)&lt;/p&gt;

&lt;h3&gt;request.setTimeout(timeout, [callback])&lt;/h3&gt;

&lt;p&gt;Once a socket is assigned to this request and is connected
&lt;a href=&quot;net.html#net_socket_settimeout_timeout_callback&quot;&gt;socket.setTimeout()&lt;/a&gt; will be called.&lt;/p&gt;

&lt;h3&gt;request.setNoDelay([noDelay])&lt;/h3&gt;

&lt;p&gt;Once a socket is assigned to this request and is connected
&lt;a href=&quot;net.html#net_socket_setnodelay_nodelay&quot;&gt;socket.setNoDelay()&lt;/a&gt; will be called.&lt;/p&gt;

&lt;h3&gt;request.setSocketKeepAlive([enable], [initialDelay])&lt;/h3&gt;

&lt;p&gt;Once a socket is assigned to this request and is connected
&lt;a href=&quot;net.html#net_socket_setkeepalive_enable_initialdelay&quot;&gt;socket.setKeepAlive()&lt;/a&gt; will be called.&lt;/p&gt;

&lt;h2&gt;http.IncomingMessage&lt;/h2&gt;

&lt;p&gt;An &lt;code&gt;IncomingMessage&lt;/code&gt; object is created by &lt;code&gt;http.Server&lt;/code&gt; or &lt;code&gt;http.ClientRequest&lt;/code&gt;
and passed as the first argument to the &lt;code&gt;&#39;request&#39;&lt;/code&gt; and &lt;code&gt;&#39;response&#39;&lt;/code&gt; event
respectively. It may be used to access response status, headers and data.&lt;/p&gt;

&lt;p&gt;It implements the &lt;a href=&quot;stream.html#stream_readable_stream&quot;&gt;Readable Stream&lt;/a&gt; interface, as well as the
following additional events, methods, and properties.&lt;/p&gt;

&lt;h3&gt;Event: &#39;close&#39;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;function () { }&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Indicates that the underlaying connection was terminated before
&lt;code&gt;response.end()&lt;/code&gt; was called or able to flush.&lt;/p&gt;

&lt;p&gt;Just like &lt;code&gt;&#39;end&#39;&lt;/code&gt;, this event occurs only once per response. See
[http.ServerResponse][]&#39;s &lt;code&gt;&#39;close&#39;&lt;/code&gt; event for more information.&lt;/p&gt;

&lt;h3&gt;message.httpVersion&lt;/h3&gt;

&lt;p&gt;In case of server request, the HTTP version sent by the client. In the case of
client response, the HTTP version of the connected-to server.
Probably either &lt;code&gt;&#39;1.1&#39;&lt;/code&gt; or &lt;code&gt;&#39;1.0&#39;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Also &lt;code&gt;response.httpVersionMajor&lt;/code&gt; is the first integer and
&lt;code&gt;response.httpVersionMinor&lt;/code&gt; is the second.&lt;/p&gt;

&lt;h3&gt;message.headers&lt;/h3&gt;

&lt;p&gt;The request/response headers object.&lt;/p&gt;

&lt;p&gt;Read only map of header names and values. Header names are lower-cased.
Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Prints something like:
//
// { &#39;user-agent&#39;: &#39;curl/7.22.0&#39;,
//   host: &#39;127.0.0.1:8000&#39;,
//   accept: &#39;*/*&#39; }
console.log(request.headers);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;message.rawHeaders&lt;/h3&gt;

&lt;p&gt;The raw request/response headers list exactly as they were received.&lt;/p&gt;

&lt;p&gt;Note that the keys and values are in the same list.  It is &lt;em&gt;not&lt;/em&gt; a
list of tuples.  So, the even-numbered offsets are key values, and the
odd-numbered offsets are the associated values.&lt;/p&gt;

&lt;p&gt;Header names are not lowercased, and duplicates are not merged.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Prints something like:
//
// [ &#39;user-agent&#39;,
//   &#39;this is invalid because there can be only one&#39;,
//   &#39;User-Agent&#39;,
//   &#39;curl/7.22.0&#39;,
//   &#39;Host&#39;,
//   &#39;127.0.0.1:8000&#39;,
//   &#39;ACCEPT&#39;,
//   &#39;*/*&#39; ]
console.log(request.rawHeaders);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;message.trailers&lt;/h3&gt;

&lt;p&gt;The request/response trailers object. Only populated at the &#39;end&#39; event.&lt;/p&gt;

&lt;h3&gt;message.rawTrailers&lt;/h3&gt;

&lt;p&gt;The raw request/response trailer keys and values exactly as they were
received.  Only populated at the &#39;end&#39; event.&lt;/p&gt;

&lt;h3&gt;message.setTimeout(msecs, callback)&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;msecs&lt;/code&gt; {Number}&lt;/li&gt;
&lt;li&gt;&lt;code&gt;callback&lt;/code&gt; {Function}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Calls &lt;code&gt;message.connection.setTimeout(msecs, callback)&lt;/code&gt;.&lt;/p&gt;

&lt;h3&gt;message.method&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Only valid for request obtained from &lt;code&gt;http.Server&lt;/code&gt;.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The request method as a string. Read only. Example:
&lt;code&gt;&#39;GET&#39;&lt;/code&gt;, &lt;code&gt;&#39;DELETE&#39;&lt;/code&gt;.&lt;/p&gt;

&lt;h3&gt;message.url&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Only valid for request obtained from &lt;code&gt;http.Server&lt;/code&gt;.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Request URL string. This contains only the URL that is
present in the actual HTTP request. If the request is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GET /status?name=ryan HTTP/1.1\r\n
Accept: text/plain\r\n
\r\n
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then &lt;code&gt;request.url&lt;/code&gt; will be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;/status?name=ryan&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you would like to parse the URL into its parts, you can use
&lt;code&gt;require(&#39;url&#39;).parse(request.url)&lt;/code&gt;.  Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node&amp;gt; require(&#39;url&#39;).parse(&#39;/status?name=ryan&#39;)
{ href: &#39;/status?name=ryan&#39;,
  search: &#39;?name=ryan&#39;,
  query: &#39;name=ryan&#39;,
  pathname: &#39;/status&#39; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you would like to extract the params from the query string,
you can use the &lt;code&gt;require(&#39;querystring&#39;).parse&lt;/code&gt; function, or pass
&lt;code&gt;true&lt;/code&gt; as the second argument to &lt;code&gt;require(&#39;url&#39;).parse&lt;/code&gt;.  Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node&amp;gt; require(&#39;url&#39;).parse(&#39;/status?name=ryan&#39;, true)
{ href: &#39;/status?name=ryan&#39;,
  search: &#39;?name=ryan&#39;,
  query: { name: &#39;ryan&#39; },
  pathname: &#39;/status&#39; }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;message.statusCode&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Only valid for response obtained from &lt;code&gt;http.ClientRequest&lt;/code&gt;.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The 3-digit HTTP response status code. E.G. &lt;code&gt;404&lt;/code&gt;.&lt;/p&gt;

&lt;h3&gt;message.socket&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;net.Socket&lt;/code&gt; object associated with the connection.&lt;/p&gt;

&lt;p&gt;With HTTPS support, use request.connection.verifyPeer() and
request.connection.getPeerCertificate() to obtain the client&#39;s
authentication details.&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>生命不息，折腾不止</title>
     <link href="http://alankell.github.io/keeping"/>
     <updated>2013-11-19T00:00:00+08:00</updated>
     <id>http://http://alankell.github.io/keeping</id>
     <content type="html">&lt;h2&gt;Good is not Enough&lt;/h2&gt;

&lt;p&gt;这个时代是属于偏执狂的，正如乔布斯那样.做事情总是一味地迁就，不能精益求精总归是走不长的，
时代决定了我们的需求，现代社会我们什么也不缺物质，馒头面包我们都有，我们追求的是品质，人们需
要更加人性化更智能的产品和更高质量的物质享受和精神享受，所以对于我们做技术的如果只满足于实现
某个功能就OK是肯定成不了大事的，我们需要追求完美。好吧，虽然我不信星座，但身为处女座的我从小
到大的确有点完美主义，而且还有点轻微的洁癖，那些攻击处女座的可以来喷了... ~_~!&lt;/p&gt;

&lt;h2&gt;利用Jekyll搭建github Blog&lt;/h2&gt;

&lt;p&gt;其实一直想搭建一个个人blog,首先我比较崇尚极简主义，不喜欢乱七八糟的广告和插件，其次一些博客网站的排版和字体并不能满足我这方面有洁癖的要求，jekyll用的是markdown转静态页面，英文字体还算过得去，中文字体在后期我还是得再加强一下。之前也用&lt;a href=&quot;https://ghost.org/&quot;&gt;Ghost&lt;/a&gt;搭建过一个，它是基于node.js的一个bloging platform,那个相对简单，简单的模板都已经写好，当时就很快弄了一个，并且网上弄了一个免费的VPS，可是免费的终归是不靠谱，总是掉，别且有次数据丢失，虽然那个平台很好，很简洁很漂亮，但是作为一个买不起VPS的穷学生来说，也就丢弃了。&lt;/p&gt;

&lt;p&gt;github pages也是很早就知道的，为什么没有动手开干？也是因为担心其访问速度太蜗牛，因为这个毕竟是外国的网站的，后来发现身边的很多人都用github pages当博客，并且速度真心还可以，于是经不住诱惑，也弄了一个，目前这个模板仅做了不多的修改，现在也在孕育下一个改版，相信不久就会有一个更简洁更具人文情怀的blog诞生。&lt;/p&gt;

&lt;p&gt;虽然整个搭建过程很清晰，但是中间还是出现了很多的小问题，坑爹的ruby安装好之后，install jekyll的时候，由于天朝的网络的原因，多次尝试才成功，对那个武汉大学流氓教授真是无语，弄什么不好弄防火墙。。。&lt;/p&gt;

&lt;h3&gt;1.安装&lt;a href=&quot;http://jekyllrb.com/&quot;&gt;jekyll&lt;/a&gt;&lt;/h3&gt;

&lt;pre class=&quot;prettify&quot;&gt;
    gem install jekyll
&lt;/pre&gt;


&lt;h3&gt;2.用Jekyll构建基于bootstrap模板&lt;/h3&gt;

&lt;pre class=&quot;prettify&quot;&gt;
$ git clone https://github.com/plusjade/jekyll-bootstrap.git
$ cd jekyll-bootstrap
$ jekyll --server
&lt;/pre&gt;


&lt;p&gt;接下就可以在浏览器中预览啦http://localhost:4000/&lt;/p&gt;

&lt;h3&gt;3.enjoy&lt;/h3&gt;

&lt;p&gt;不过我用的不是这个简单的自模板，所以当时本地调试的时候也是遇到了很多的问题，不过一路斩荆棘下来还是学到了不少，但是当时我没有全程记录，
所以现在也不能全部分享给大家了，BeiYu在他博客上提到的一个问题“放在根目录下面的blog.md等文件，在GitHub的pages服务上一切正常，但是在本地环境下，总是not found，很是让人郁闷，看生成的_site目录下面的文件，也是正常的blog.html，但就是找不到，只有当我把URL改为localhost:4000/blog.html的时候，才能访问的到，环境不同真糟糕。”其实我也遇到，但是我发现只要commit post以后，关闭jekyll serve再重启以后，本地访问就会出现了，我想这应该是一个实时更新的一个问题。&lt;/p&gt;

&lt;h3&gt;4.Jekyll基本结构&lt;/h3&gt;

&lt;p&gt;这一路下来，我觉得对这个熟悉是至关重要的，Jekyll的核心其实就是一个文本的转换引擎，用你最喜欢的标记语言写文档，可以是Markdown、Textile或者HTML等等，再通过layout将文档拼装起来，根据你设置的URL规则来展现，这些都是通过严格的配置文件来定义，最终的产出就是web页面&lt;/p&gt;

&lt;p&gt;jekyll结构如下：&lt;/p&gt;

&lt;pre class=&quot;prettify&quot;&gt;
|-- _config.yml
|-- _includes
|-- _layouts
|   |-- default.html
|   `-- post.html
|-- _posts
|   |-- 2007-10-29-why-every-programmer-should-play-nethack.textile
|   `-- 2009-04-26-barcamp-boston-4-roundup.textile
|-- _site
`-- index.html
&lt;/pre&gt;


&lt;h2&gt;心得&lt;/h2&gt;

&lt;p&gt;要做好一个东西还是得学会hack，好好折腾啊，git是一个好东西，我从用了linux之后才深刻体会到 命令行的方便，Git Bash也是用命令行操作的，发现其强大及便捷太适合码农们了，
下面一张图可以让你快速了解git操作了（右键另存为吧  哈哈~）&lt;img src=&quot;/images/githubpages/git.png&quot; alt=&quot;Git&quot; /&gt;&lt;/p&gt;

&lt;p&gt;不早了，下次再扯了，晚安！&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>辉火</title>
     <link href="http://alankell.github.io/huihuo"/>
     <updated>2010-06-08T00:00:00+08:00</updated>
     <id>http://http://alankell.github.io/huihuo</id>
     <content type="html">&lt;p&gt;&lt;img src=&quot;https://dl.dropboxusercontent.com/u/36894032/huihuo.jpg&quot; alt=&quot;huihuo&quot; /&gt;&lt;/p&gt;

&lt;center&gt;
他是孤傲的,
&lt;br /&gt;&lt;br /&gt;

在他的眼里

&lt;br /&gt;&lt;br /&gt;
除了冥王所有的一切都是虚无,

&lt;br /&gt;&lt;br /&gt;
燃烧灵魂，
&lt;br /&gt;
&lt;br /&gt;
得到的是忘记过去的邪恶
&lt;br /&gt;
&lt;br /&gt;
只为舍弃那颗曾经做为人类的心灵！
&lt;br /&gt;
&lt;br /&gt;
黑炎漫天，
&lt;br /&gt;
&lt;br /&gt;
这就是你的生存之道啊！
&lt;br /&gt;
&lt;br /&gt;
烧尽一切，
&lt;br /&gt;
&lt;br /&gt;
这就是你的战斗理念啊！
&lt;br /&gt;
&lt;br /&gt;
曾经那宽容的笑脸没有让你醒悔，
&lt;br /&gt;
&lt;br /&gt;
曾经那悲伤的内心不曾使你动心，
&lt;br /&gt;
&lt;br /&gt;
你就是你，没有人能动摇你！
&lt;br /&gt;
&lt;br /&gt;
这就是贝努鸟吗？
&lt;br /&gt;
&lt;br /&gt;
忘不了那一战，
&lt;br /&gt;
&lt;br /&gt;
一场没有退路，一飞冲天的战斗，
&lt;br /&gt;
&lt;br /&gt;
你终于醒悟到了！
&lt;br /&gt;
&lt;br /&gt;
只有守护自己要守护的东西，
&lt;br /&gt;
&lt;br /&gt;
才能让自己完美的蜕变！
&lt;br /&gt;
&lt;br /&gt;
你终于明白了，
&lt;br /&gt;
&lt;br /&gt;
战斗的最终目的，
&lt;br /&gt;
&lt;br /&gt;
不为自己，
&lt;br /&gt;
&lt;br /&gt;
只是为了保护自己重要的人！
&lt;br /&gt;
&lt;br /&gt;
黑炎变色了......
&lt;br /&gt;
&lt;br /&gt;
你感叹了自己的命运，
&lt;br /&gt;
&lt;br /&gt;
是的，作为战士
&lt;br /&gt;
&lt;br /&gt;
这样的觉悟不晚！
&lt;br /&gt;
&lt;br /&gt;
当你飞向太阳彼端时，
&lt;br /&gt;
&lt;br /&gt;
圣的历史不会将你忘记！
&lt;br /&gt;
&lt;br /&gt;
火凤凰中将还会归来！
&lt;/center&gt;



</content>
   </entry>
   
   <entry>
     <title>致处女座阿释密达</title>
     <link href="http://alankell.github.io/asimita"/>
     <updated>2009-11-28T00:00:00+08:00</updated>
     <id>http://http://alankell.github.io/asimita</id>
     <content type="html">&lt;p&gt;&lt;img src=&quot;/images/blog/asimita.jpg&quot; alt=&quot;asimita&quot; /&gt;
这是，有一个清晨的到来，如同往昔一般的阳光，洒进圣域的每一个角落。白色的大理石反射着阳光。在这里，光与影是如此分明，然而，尘世间的一切，却往往不是如此……&lt;/p&gt;

&lt;p&gt;他看见，一个个人在他眼前来了又去；他看见，一幕幕在他眼前一再重复。他，本该是无法看见的，然而造化就是如此的不公，在剥夺他以表相取物的能力的时候，又给了他一双，能够看透真相的眼睛。眼中的这个世界，本该是是非曲折，黑白分明，却偏偏要用一种似是而非的状态纠结在一起，作弄人间。这本是，多么愚昧的事情。&lt;/p&gt;

&lt;p&gt;然而，及时他不愿去看，却不得不看。一个个轮回，一幕幕再现。彼岸的荼黎开的灿烂，一场场悲欢，触动他的心。看到过去，看到未来，有些人在他身边徘徊，他却无法抓住任何的契机。自始自终，这条注定的不归路上，他还是一人独行。&lt;/p&gt;

&lt;p&gt;这个世上，本没有所谓完全的正义，完全的邪恶。有一天，他在一片黑暗中看见了，那个金发的青年。百年后，这条不归路上，有个青年这么说。&lt;/p&gt;

&lt;p&gt;这个世上，哪个圣洁？谁又有资格论断别人的善恶？而这，是他在不归路上找寻的答案。&lt;/p&gt;

&lt;p&gt;于是，他寻找，用可以看穿过去未来的眼睛去寻找。千年，万年，直到恒河沙，那由他数。却还是徘徊在无间中，无法自拔。太多的困扰，太多的悲苦。因为，他的问题太难，他的理念太执着。那么，对于问题，到底是该执着还是放弃，对于迷茫，是该继续还是该回头。佛陀的慈悲，凡人的无奈，偏偏这两种感情左右的是一个人的躯体，如此的两种感情，怎样拆开。好尖锐的问题，好困难的抉择。&lt;/p&gt;

&lt;p&gt;愿为佛陀，却成心魔，执着是苦，走火入魔。&lt;/p&gt;

&lt;p&gt;他还是无法，还是无法在那个少年或那个少女身上找到答案。不是说，那么简单的说辞，就能解答他千年的疑问，这样的事情，这样的回答，他已经看的太多，他只是，已经觉得厌倦了，不想再找下去了，心的缺口，已经太多了……&lt;/p&gt;

&lt;p&gt;推开沉重的莲花门，手植的沙罗双树方才突出些许的新绿，到底还是无法适应这里的环境麽？这本是，在极乐世界的树啊。树犹如此，人何以堪？他们，都是不该来到这个尘世的。永远会不去的地方是故乡，永远到不了的地方是彼岸，徘徊其间的无主孤魂，该是怎样的悲苦。但是，至少这树，还有等待的时间，等待的人。他看到了，百年后，粉花飞散，一生惟一的一次绽放，落成了满天满地的芬芳。金发的青年，带着释然的微笑回到这树下，回到这，他曾经死去的地方。&lt;/p&gt;

&lt;p&gt;他微微的笑着，笑着那个继续他无间之行的人。这条路太苦，苦的连他都不由得放弃了。你，又能够走多久呢？你能找到麽，我没有找到的答案，你能找到麽，填补我心的缺口的方法……我的一切，都已经留给了你。然后，是我该走的时候了……&lt;/p&gt;

&lt;p&gt;阿释密达，你要去哪里？&lt;/p&gt;

&lt;p&gt;我是处女座的阿释密达，不多一分，不少一分，圣斗士该去的地方，通常只有自己死的地方吧……
是的，我已经是，不想再留在这个尘世的人了……&lt;/p&gt;

&lt;p&gt;阳光很温暖，微微有风，吹动手中未完成的念珠。唯一不好的，只有塔下传来的杀气，还有冥界特有的死人的气息。&lt;/p&gt;

&lt;p&gt;然而，不会死的东西是不被天地容许存在的，不死，你们将何处生？&lt;/p&gt;

&lt;p&gt;平生唯一一次，也是最后一次睁开双眼，却是为了完成无情的杀戮。他看见，靠近他身边的敌人飞了出去，血，落了满天。好似，百年后，沙罗树的花瓣，飞翔天际。&lt;/p&gt;

&lt;p&gt;时间，终止了脚步，身体，逐渐消散。终于，是可以走的时候了。光华散去，他看见了，阳光，村落……原来，只从表面看事物是如此的轻松美丽。天，你果然，对我不公啊……微微的叹息一声，是最后的心愿，如果还有来生，我只愿看到如此的平凡……&lt;/p&gt;

&lt;p&gt;……&lt;/p&gt;

&lt;p&gt;一身胆，你能挡千万关，一片心，叹悔情路难，情路难，无情更难，情已去不复还&lt;/p&gt;

&lt;p&gt;一双眼，你能成千人斩，一声叹，催折英雄汉，英雄汉，生死看淡，只恨天妒红颜&lt;/p&gt;

&lt;p&gt;身在无间，颠颠倒倒，注定一生波澜&lt;/p&gt;

&lt;p&gt;人生再无遗憾，相识已是困难&lt;/p&gt;

&lt;p&gt;世路已倦，曲曲弯弯，看伊能磨吾几番&lt;/p&gt;

&lt;p&gt;来生若有心愿，万水千山，平凡……&lt;/p&gt;
</content>
   </entry>
   
 
</feed>
